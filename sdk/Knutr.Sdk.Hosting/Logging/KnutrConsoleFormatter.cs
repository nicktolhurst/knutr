namespace Knutr.Sdk.Hosting.Logging;

using Serilog.Events;
using Serilog.Formatting;
using Serilog.Parsing;

/// <summary>
/// Custom Serilog text formatter that produces colorized, Nerd Font-enhanced console output.
/// Each service gets a deterministic color so interleaved kubectl logs are easy to scan.
///
/// Brand palette:
///   Theme  — a small set of pastel colors for UI chrome (icons, values, warnings).
///   Service — a larger generated pastel palette (24 hues) for service identification.
///   Colors are derived from the full service name before any truncation for display,
///   so they remain stable even if the column width changes.
/// </summary>
public sealed class KnutrConsoleFormatter : ITextFormatter
{
    private const string Reset = "\x1b[0m";
    private const string Dim = "\x1b[2m";
    private const string Bold = "\x1b[1m";

    // ── Brand / theme colors (pastel) ───────────────────────────────────────
    private const string ThemeTeal     = "\x1b[38;2;121;204;204m"; // info icon
    private const string ThemeAmber    = "\x1b[38;2;219;182;112m"; // warning icon + message
    private const string ThemeRose     = "\x1b[38;2;214;132;132m"; // error icon + message
    private const string ThemeCoral    = "\x1b[38;2;214;128;116m"; // fatal icon + message

    private const int DefaultColumnWidth = 4;

    private readonly string _serviceTag;
    private readonly string _serviceColorMuted;
    private readonly int _columnWidth;

    // ── Service palette (24 pastel hues, S=0.55 L=0.72) ────────────────────
    // Generated by rotating hue in 15° steps at fixed saturation/lightness.
    // 24 entries give enough variation that FNV-1a collisions are rare.
    private static readonly string[] ServiceColors =
    [
        "\x1b[38;2;222;144;144m", // hue   0°
        "\x1b[38;2;222;163;144m", // hue  15°
        "\x1b[38;2;222;183;144m", // hue  30°
        "\x1b[38;2;222;203;144m", // hue  45°
        "\x1b[38;2;222;222;144m", // hue  60°
        "\x1b[38;2;203;222;144m", // hue  75°
        "\x1b[38;2;183;222;144m", // hue  90°
        "\x1b[38;2;163;222;144m", // hue 105°
        "\x1b[38;2;144;222;144m", // hue 120°
        "\x1b[38;2;144;222;163m", // hue 135°
        "\x1b[38;2;144;222;183m", // hue 150°
        "\x1b[38;2;144;222;203m", // hue 165°
        "\x1b[38;2;144;222;222m", // hue 180°
        "\x1b[38;2;144;203;222m", // hue 195°
        "\x1b[38;2;144;183;222m", // hue 210°
        "\x1b[38;2;144;163;222m", // hue 225°
        "\x1b[38;2;144;144;222m", // hue 240°
        "\x1b[38;2;163;144;222m", // hue 255°
        "\x1b[38;2;183;144;222m", // hue 270°
        "\x1b[38;2;203;144;222m", // hue 285°
        "\x1b[38;2;222;144;222m", // hue 300°
        "\x1b[38;2;222;144;203m", // hue 315°
        "\x1b[38;2;222;144;183m", // hue 330°
        "\x1b[38;2;222;144;163m", // hue 345°
    ];

    // ── Muted service palette (same hues, S=0.15 L=0.40) ────────────────────
    // Used for template values and timestamps — same hue as the service tag but dimmer.
    private static readonly string[] ServiceColorsMuted =
    [
        "\x1b[38;2;117;86;86m",  // hue   0°
        "\x1b[38;2;117;94;86m",  // hue  15°
        "\x1b[38;2;117;102;86m", // hue  30°
        "\x1b[38;2;117;109;86m", // hue  45°
        "\x1b[38;2;117;117;86m", // hue  60°
        "\x1b[38;2;109;117;86m", // hue  75°
        "\x1b[38;2;102;117;86m", // hue  90°
        "\x1b[38;2;94;117;86m",  // hue 105°
        "\x1b[38;2;86;117;86m",  // hue 120°
        "\x1b[38;2;86;117;94m",  // hue 135°
        "\x1b[38;2;86;117;102m", // hue 150°
        "\x1b[38;2;86;117;109m", // hue 165°
        "\x1b[38;2;86;117;117m", // hue 180°
        "\x1b[38;2;86;109;117m", // hue 195°
        "\x1b[38;2;86;101;117m", // hue 210°
        "\x1b[38;2;86;94;117m",  // hue 225°
        "\x1b[38;2;86;86;117m",  // hue 240°
        "\x1b[38;2;94;86;117m",  // hue 255°
        "\x1b[38;2;101;86;117m", // hue 270°
        "\x1b[38;2;109;86;117m", // hue 285°
        "\x1b[38;2;117;86;117m", // hue 300°
        "\x1b[38;2;117;86;109m", // hue 315°
        "\x1b[38;2;117;86;102m", // hue 330°
        "\x1b[38;2;117;86;94m",  // hue 345°
    ];

    public KnutrConsoleFormatter(string serviceName, int columnWidth = DefaultColumnWidth)
    {
        _columnWidth = columnWidth;
        // Color is always derived from the full name — stable across truncation widths.
        var idx = GetServiceColorIndex(serviceName);
        var serviceColor = ServiceColors[idx];
        _serviceColorMuted = ServiceColorsMuted[idx];
        var display = serviceName.Length > columnWidth
            ? serviceName[..columnWidth]
            : serviceName.PadRight(columnWidth);
        _serviceTag = $"{serviceColor}{display}{Reset}";
    }

    public void Format(LogEvent logEvent, TextWriter output)
    {
        var (icon, levelColor, messageColor) = GetLevelStyle(logEvent.Level);

        // Timestamp (muted service color)
        output.Write(_serviceColorMuted);
        output.Write('[');
        output.Write(logEvent.Timestamp.ToString("HH:mm:ss"));
        output.Write(']');
        output.Write(Reset);
        output.Write(' ');

        // Level icon (colored by severity)
        output.Write(levelColor);
        output.Write(icon);
        output.Write(Reset);
        output.Write("  ");

        // Service tag (deterministic color per service)
        output.Write(_serviceTag);
        output.Write(' ');

        // Message (colored by severity for warnings/errors, default for info)
        // Template values are highlighted in the service's own color.
        if (messageColor.Length > 0)
            output.Write(messageColor);

        foreach (var token in logEvent.MessageTemplate.Tokens)
        {
            if (token is PropertyToken)
            {
                output.Write(_serviceColorMuted);
                token.Render(logEvent.Properties, output);
                output.Write(messageColor.Length > 0 ? messageColor : Reset);
            }
            else
            {
                token.Render(logEvent.Properties, output);
            }
        }

        if (messageColor.Length > 0)
            output.Write(Reset);

        output.WriteLine();

        // Exception block (rose, indented to align with message column)
        if (logEvent.Exception is not null)
        {
            var indent = new string(' ', 11 + _columnWidth);
            output.Write(ThemeRose);
            foreach (var line in logEvent.Exception.ToString().AsSpan().EnumerateLines())
            {
                output.Write(indent);
                output.WriteLine(line.TrimEnd());
            }
            output.Write(Reset);
        }
    }

    /// <summary>
    /// Returns (NerdFont icon, level ANSI color, message ANSI color) for a given log level.
    /// Info messages use default terminal color so they don't distract;
    /// warnings and errors stand out in pastel amber / rose.
    /// </summary>
    private static (string Icon, string LevelColor, string MessageColor) GetLevelStyle(LogEventLevel level) =>
        level switch
        {
            LogEventLevel.Verbose     => ("\uf10c", Dim,                    Dim),               //  circle-o
            LogEventLevel.Debug       => ("\uf188", Dim,                    Dim),               //  bug
            LogEventLevel.Information => ("\uf05a", ThemeTeal,              ""),                 //  info-circle
            LogEventLevel.Warning     => ("\uf071", ThemeAmber,             ThemeAmber),         //  warning
            LogEventLevel.Error       => ("\uf057", ThemeRose,              ThemeRose),          //  times-circle
            LogEventLevel.Fatal       => ("\uf06d", ThemeCoral + Bold,      ThemeCoral + Bold),  //  fire
            _                         => ("?",      "",                      ""),
        };

    // FNV-1a hash for deterministic, well-distributed color assignment.
    // Mirrored in the knutr CLI script so colors match everywhere.
    private static int GetServiceColorIndex(string serviceName)
    {
        uint hash = 2166136261;
        foreach (var c in serviceName)
            hash = (hash ^ c) * 16777619;
        return (int)(hash % (uint)ServiceColors.Length);
    }
}
